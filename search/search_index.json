{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Use MollyEngine to develop you own 2D games in C#. The MolluEngineDocs are here to help you in you game development journey and teach you how to use MollyEngine and its extensions. If you are unfamiliar with MollyEngine, it is advised to visit the quick start guide","title":"Home"},{"location":"#home","text":"Use MollyEngine to develop you own 2D games in C#. The MolluEngineDocs are here to help you in you game development journey and teach you how to use MollyEngine and its extensions. If you are unfamiliar with MollyEngine, it is advised to visit the quick start guide","title":"Home"},{"location":"quick_start/","text":"Quick Start In this quick start guide we will make game in which the player will be collecting coins. To begin with lets create our game window as follows public class DemoGame : Core.MollyEngine { public DemoGame() : base(\"New Game\") { } } The code above creates our DemoGame object and passes in a parameter, a title. Now that our DemoGame object is setup lets get started on setting up the player movement. MollyEngine offers some great extensions which help you out prototype and implement your ideas faster, one of which is the PlayerController extension . The engine offers some event's, similarly to Unity, Unreal etc that you can implement such as OnLoad . public override void OnLoad() { player = new Sprite2D(new Vector2(100, 100), new Scale(100, 100), Path.GetFullPath(@\"Images\\player.jpg\") , \"Player\", 1); playerController = new PlayerController(player, speed); } Remember: Make sure to import MollyEngine.Extensions This code creates a Sprite2D , which is our player and passes him to the player controller extension.The constructor used for our player sprite has the following signature: Sprite2D(Vector2 position, Scale scale, string directory, string tag, uint renderingPriority) . The PlayerController extension needs to be implemented in the following events for it to work properly: public override void OnUpdate() { playerController.Update(); } public override void OnKeyDown(KeyEventArgs e) { playerController.OnKeyDownHandler(e); } public override void OnKeyUp(KeyEventArgs e) { playerController.OnKeyUpHandler(e); } Remember: PlayerController is an extension and not part of the core framework and that's why you need to call the above methods by yourself! We should at this point have a character which can move around freely withing our screen, so its time we spawn in our coins. Coins are just sprites that need to be spawned at a random point on startup so it only makes sense that we add the coin spawning code to the OnLoad method. public override void OnLoad() { // Previous Code player = new Sprite2D(new Vector2(100, 100), new Scale(100, 100), Path.GetFullPath(@\"Images\\player.jpg\") , \"Player\", 1); playerController = new PlayerController(player, speed); // // New Code - Coin spawning // for (int i = 0; i < 30; i++) { Sprite2D coin = new Sprite2D(new Vector2(rnd.Next(0, 1200), rnd.Next(0, 800)), new Scale(50, 50), Path.GetFullPath(@\"Images\\coin.jpg\"), $\"coin{i}\"); } } Remember: rnd is of type System.Random so you will need to create a variable of type System.Random named rnd! Go ahead test it out, our coins are spawning in but you may have noticed that we cannot pick up/collect those coins, so how would we go about implementing the coin collection system? Well we will need to do some collision detection preferably on the OnUpdate method/event. public override void OnUpdate() { // Previous Code playerController.Update(); // // New Code - Collision detection // GameObject collide; if (sprite.isColliding(out collide)) { Sprite2D coin = (Sprite2D)collide; coin.DestroySelf(); } } The code above checks every frame to see whether or not our player is colliding with something, if it is the collide is passed to the collide variable as a GameObject . Then we create a Sprite2D named coin out of the GameObject and destroy it, essentially removing it from the game. The full code is available here: using System; using System.Windows.Forms; using MollyEngine; using MollyEngine.Core; using System.IO; using MollyEngine.Extensions; namespace MollyEngine { public class DemoGame : Core.MollyEngine { Sprite2D sprite; ulong speed = 1; Random rnd = new Random(); PlayerController playerController; public DemoGame() : base(\"New Game\") { } public override void OnLoad() { sprite = new Sprite2D(new Vector2(100, 100), new Scale(100, 100), Path.GetFullPath(@\"Images\\player.jpg\") , \"Player\", 1); playerController = new PlayerController(sprite, speed); for (int i = 0; i < 30; i++) { Sprite2D coin = new Sprite2D(new Vector2(rnd.Next(0, 1200), rnd.Next(0, 800)), new Scale(50, 50), Path.GetFullPath(@\"Images\\coin.jpg\"), $\"coin{i}\"); } } public override void OnUpdate() { playerController.Update(); GameObject collide; if (sprite.isColliding(out collide)) { Sprite2D coin = (Sprite2D)collide; coin.DestroySelf(); } } public override void OnKeyDown(KeyEventArgs e) { playerController.OnKeyDownHandler(e); } public override void OnKeyUp(KeyEventArgs e) { playerController.OnKeyUpHandler(e); } } }","title":"Quick Start"},{"location":"quick_start/#quick-start","text":"In this quick start guide we will make game in which the player will be collecting coins. To begin with lets create our game window as follows public class DemoGame : Core.MollyEngine { public DemoGame() : base(\"New Game\") { } } The code above creates our DemoGame object and passes in a parameter, a title. Now that our DemoGame object is setup lets get started on setting up the player movement. MollyEngine offers some great extensions which help you out prototype and implement your ideas faster, one of which is the PlayerController extension . The engine offers some event's, similarly to Unity, Unreal etc that you can implement such as OnLoad . public override void OnLoad() { player = new Sprite2D(new Vector2(100, 100), new Scale(100, 100), Path.GetFullPath(@\"Images\\player.jpg\") , \"Player\", 1); playerController = new PlayerController(player, speed); } Remember: Make sure to import MollyEngine.Extensions This code creates a Sprite2D , which is our player and passes him to the player controller extension.The constructor used for our player sprite has the following signature: Sprite2D(Vector2 position, Scale scale, string directory, string tag, uint renderingPriority) . The PlayerController extension needs to be implemented in the following events for it to work properly: public override void OnUpdate() { playerController.Update(); } public override void OnKeyDown(KeyEventArgs e) { playerController.OnKeyDownHandler(e); } public override void OnKeyUp(KeyEventArgs e) { playerController.OnKeyUpHandler(e); } Remember: PlayerController is an extension and not part of the core framework and that's why you need to call the above methods by yourself! We should at this point have a character which can move around freely withing our screen, so its time we spawn in our coins. Coins are just sprites that need to be spawned at a random point on startup so it only makes sense that we add the coin spawning code to the OnLoad method. public override void OnLoad() { // Previous Code player = new Sprite2D(new Vector2(100, 100), new Scale(100, 100), Path.GetFullPath(@\"Images\\player.jpg\") , \"Player\", 1); playerController = new PlayerController(player, speed); // // New Code - Coin spawning // for (int i = 0; i < 30; i++) { Sprite2D coin = new Sprite2D(new Vector2(rnd.Next(0, 1200), rnd.Next(0, 800)), new Scale(50, 50), Path.GetFullPath(@\"Images\\coin.jpg\"), $\"coin{i}\"); } } Remember: rnd is of type System.Random so you will need to create a variable of type System.Random named rnd! Go ahead test it out, our coins are spawning in but you may have noticed that we cannot pick up/collect those coins, so how would we go about implementing the coin collection system? Well we will need to do some collision detection preferably on the OnUpdate method/event. public override void OnUpdate() { // Previous Code playerController.Update(); // // New Code - Collision detection // GameObject collide; if (sprite.isColliding(out collide)) { Sprite2D coin = (Sprite2D)collide; coin.DestroySelf(); } } The code above checks every frame to see whether or not our player is colliding with something, if it is the collide is passed to the collide variable as a GameObject . Then we create a Sprite2D named coin out of the GameObject and destroy it, essentially removing it from the game. The full code is available here: using System; using System.Windows.Forms; using MollyEngine; using MollyEngine.Core; using System.IO; using MollyEngine.Extensions; namespace MollyEngine { public class DemoGame : Core.MollyEngine { Sprite2D sprite; ulong speed = 1; Random rnd = new Random(); PlayerController playerController; public DemoGame() : base(\"New Game\") { } public override void OnLoad() { sprite = new Sprite2D(new Vector2(100, 100), new Scale(100, 100), Path.GetFullPath(@\"Images\\player.jpg\") , \"Player\", 1); playerController = new PlayerController(sprite, speed); for (int i = 0; i < 30; i++) { Sprite2D coin = new Sprite2D(new Vector2(rnd.Next(0, 1200), rnd.Next(0, 800)), new Scale(50, 50), Path.GetFullPath(@\"Images\\coin.jpg\"), $\"coin{i}\"); } } public override void OnUpdate() { playerController.Update(); GameObject collide; if (sprite.isColliding(out collide)) { Sprite2D coin = (Sprite2D)collide; coin.DestroySelf(); } } public override void OnKeyDown(KeyEventArgs e) { playerController.OnKeyDownHandler(e); } public override void OnKeyUp(KeyEventArgs e) { playerController.OnKeyUpHandler(e); } } }","title":"Quick Start"},{"location":"About/license/","text":"License MollyEngine is under the Apache 2.0 license Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"License"},{"location":"About/license/#license","text":"MollyEngine is under the Apache 2.0 license Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"License"},{"location":"About/progress/","text":"About The Molly Engine documentation is currently under development. It aims to document all of the engines features as well as provide some project examples as references on how you can use/implement the knowledge gained from the docs.","title":"Current Stage of Docs"},{"location":"About/progress/#about","text":"The Molly Engine documentation is currently under development. It aims to document all of the engines features as well as provide some project examples as references on how you can use/implement the knowledge gained from the docs.","title":"About"},{"location":"Core/MollyEngineClass/","text":"MollyEngine Class Description The MollyEngine class is one of the most important classes in the entire engine. You can think of this class as you game's class since all the events such as the OnLoad can only be overridden from this class. Events You can implement all of the following methods in you Game class by using the 'override' keyword. Method Description OnLoad This method is only called once on startup OnDraw This method is called directly before the window is refreshed/re-rendered OnUpdate This method is called after the window has been refreshed OnClose If you game exits normally without any exceptions this method will be called. This method gives the developer a single argument 'e' of type 'System.ComponentModel.CancelEventArgs' which allows him to cancel the game's shutdown OnException If an exception occurs during run-time this method will be called, which allows the developer to figure out what went wrong through the 'e' argument of type Exception. OnKeyDown Captures when a key is pressed.A KeyEventArg variable ispassed in the method so that the program can determine which key was pressed OnKeyUp Captures when a key is released.A KeyEventArg variable is passed in the method so that the program can determine which key was pressed OnMouseDown Captures any sort of mouse click. A MouseEventArgs variable is passed in the method so for potential further processing of this click OnMouseUp Detects when the moused is released.A MouseEventArgs variable is passed in the method so for potential further processing OnMouseDoubleClicked Captures a mouse click. A MouseEventArgs variable is passed in the method so for potential further processing OnMouseMoved Captures mouse movement. A MouseEventArgs variable is passed in the method so for potential further processing Game Window Methods Method Description Return Type setTitle Updates the windows title void getTitle Returns the windows title string Constructors Constructor Signature Description Scale ScreenSize, string Title, FormWindowState state The most detailed constructor of them all. Scale ScreenSize, string Title The 3rd ommited parameter of type FormWindowState is set to FormWindowState.Normal string Title The state is set to Normal and the Scale to 512(Width), 512 (Height) Scale ScreenSize The state is set to Normal and the title to \"New Game\" Public Properties Property Description Type backgroundColor The background color of your game System.Drawing.Color Misc The misc are uncategorized or rarely used methods or properties. Some Misc methods/properties may not be documented Method Description Return Type Is Static RegisterGameObject Makes a GameObject eligible for rendering. You only need to use if you are creating your own/custom GameObject or expanding a child of the GameObject such as the Sprite2D void Yes UnregisterGameObject Makes a GameObject uneligible for rendering. You only need to use if you are creating your own/custom GameObject or expanding a child of the GameObject such as the Sprite2D void Yes Useful links: Sprite2D Shape2D","title":"MollyEngineClass"},{"location":"Core/MollyEngineClass/#mollyengine-class","text":"","title":"MollyEngine Class"},{"location":"Core/MollyEngineClass/#description","text":"The MollyEngine class is one of the most important classes in the entire engine. You can think of this class as you game's class since all the events such as the OnLoad can only be overridden from this class.","title":"Description"},{"location":"Core/MollyEngineClass/#events","text":"You can implement all of the following methods in you Game class by using the 'override' keyword. Method Description OnLoad This method is only called once on startup OnDraw This method is called directly before the window is refreshed/re-rendered OnUpdate This method is called after the window has been refreshed OnClose If you game exits normally without any exceptions this method will be called. This method gives the developer a single argument 'e' of type 'System.ComponentModel.CancelEventArgs' which allows him to cancel the game's shutdown OnException If an exception occurs during run-time this method will be called, which allows the developer to figure out what went wrong through the 'e' argument of type Exception. OnKeyDown Captures when a key is pressed.A KeyEventArg variable ispassed in the method so that the program can determine which key was pressed OnKeyUp Captures when a key is released.A KeyEventArg variable is passed in the method so that the program can determine which key was pressed OnMouseDown Captures any sort of mouse click. A MouseEventArgs variable is passed in the method so for potential further processing of this click OnMouseUp Detects when the moused is released.A MouseEventArgs variable is passed in the method so for potential further processing OnMouseDoubleClicked Captures a mouse click. A MouseEventArgs variable is passed in the method so for potential further processing OnMouseMoved Captures mouse movement. A MouseEventArgs variable is passed in the method so for potential further processing","title":"Events"},{"location":"Core/MollyEngineClass/#game-window-methods","text":"Method Description Return Type setTitle Updates the windows title void getTitle Returns the windows title string","title":"Game Window Methods"},{"location":"Core/MollyEngineClass/#constructors","text":"Constructor Signature Description Scale ScreenSize, string Title, FormWindowState state The most detailed constructor of them all. Scale ScreenSize, string Title The 3rd ommited parameter of type FormWindowState is set to FormWindowState.Normal string Title The state is set to Normal and the Scale to 512(Width), 512 (Height) Scale ScreenSize The state is set to Normal and the title to \"New Game\"","title":"Constructors"},{"location":"Core/MollyEngineClass/#public-properties","text":"Property Description Type backgroundColor The background color of your game System.Drawing.Color","title":"Public Properties"},{"location":"Core/MollyEngineClass/#misc","text":"The misc are uncategorized or rarely used methods or properties. Some Misc methods/properties may not be documented Method Description Return Type Is Static RegisterGameObject Makes a GameObject eligible for rendering. You only need to use if you are creating your own/custom GameObject or expanding a child of the GameObject such as the Sprite2D void Yes UnregisterGameObject Makes a GameObject uneligible for rendering. You only need to use if you are creating your own/custom GameObject or expanding a child of the GameObject such as the Sprite2D void Yes Useful links: Sprite2D Shape2D","title":"Misc"},{"location":"Core/log/","text":"Log Description This static Log class allows for prettified debug message writing to the console. Public methods Method Description Parameters Return Type Normal Prints a message to the console Object msg void Info - Object msg void Warning - Object msg void Error - Object msg void getInput Prompts the user for input and returns the result Parameterless string","title":"Log"},{"location":"Core/log/#log","text":"","title":"Log"},{"location":"Core/log/#description","text":"This static Log class allows for prettified debug message writing to the console.","title":"Description"},{"location":"Core/log/#public-methods","text":"Method Description Parameters Return Type Normal Prints a message to the console Object msg void Info - Object msg void Warning - Object msg void Error - Object msg void getInput Prompts the user for input and returns the result Parameterless string","title":"Public methods"},{"location":"Core/Builtin_Datatypes/scale/","text":"Scale Description This class is used represent Scale, width and height. Properties Property Description Type Width - float Height - float Static Methods Method Description Zero A shorthand for writing Scale(0, 0) Constructors Signature Description Parameterless Initializes the Width and the Height variables to 0 float Width, float Height - Operator Overloading The following operators have been overloaded to work with the Scale class Operators + - * / == !=","title":"Scale"},{"location":"Core/Builtin_Datatypes/scale/#scale","text":"","title":"Scale"},{"location":"Core/Builtin_Datatypes/scale/#description","text":"This class is used represent Scale, width and height.","title":"Description"},{"location":"Core/Builtin_Datatypes/scale/#properties","text":"Property Description Type Width - float Height - float","title":"Properties"},{"location":"Core/Builtin_Datatypes/scale/#static-methods","text":"Method Description Zero A shorthand for writing Scale(0, 0)","title":"Static Methods"},{"location":"Core/Builtin_Datatypes/scale/#constructors","text":"Signature Description Parameterless Initializes the Width and the Height variables to 0 float Width, float Height -","title":"Constructors"},{"location":"Core/Builtin_Datatypes/scale/#operator-overloading","text":"The following operators have been overloaded to work with the Scale class Operators + - * / == !=","title":"Operator Overloading"},{"location":"Core/Builtin_Datatypes/vector2/","text":"Vector2 Description This class is used to represent 2D positions and vectors. Properties Property Description Type X The X component of the vector. float Y The Y component of the vector. float Static Methods Method Description Zero A shorthand for writing Vector2(0, 0) isEqual Returns true if the two given vectors are completely equal to one another Add Adds two vectors and returns a new vector holding the result Subtract Subtracts two vectors and returns a new vector holding the result Multiply Multiplies two vectors and returns a new vector holding the result Divide Divides two vectors and returns a new vector holding the result Constructors Signature Description Parameterless Initializes the X and Y variables to 0 float X, float Y - Operator Overloading The following operators have been overloaded to work with the Vector2 class Operators + - * / == !=","title":"Vector2"},{"location":"Core/Builtin_Datatypes/vector2/#vector2","text":"","title":"Vector2"},{"location":"Core/Builtin_Datatypes/vector2/#description","text":"This class is used to represent 2D positions and vectors.","title":"Description"},{"location":"Core/Builtin_Datatypes/vector2/#properties","text":"Property Description Type X The X component of the vector. float Y The Y component of the vector. float","title":"Properties"},{"location":"Core/Builtin_Datatypes/vector2/#static-methods","text":"Method Description Zero A shorthand for writing Vector2(0, 0) isEqual Returns true if the two given vectors are completely equal to one another Add Adds two vectors and returns a new vector holding the result Subtract Subtracts two vectors and returns a new vector holding the result Multiply Multiplies two vectors and returns a new vector holding the result Divide Divides two vectors and returns a new vector holding the result","title":"Static Methods"},{"location":"Core/Builtin_Datatypes/vector2/#constructors","text":"Signature Description Parameterless Initializes the X and Y variables to 0 float X, float Y -","title":"Constructors"},{"location":"Core/Builtin_Datatypes/vector2/#operator-overloading","text":"The following operators have been overloaded to work with the Vector2 class Operators + - * / == !=","title":"Operator Overloading"},{"location":"Core/Components/Camera/","text":"","title":"Camera"},{"location":"Core/Components/Collider/","text":"Collider Description The collider is an interface used by Sprite2D and Shape2D , you will not need it to develop you game except if you want to create a custom GameObject class which supports collision. Variable Implementations Variable Name Description Type Get/Set isColliderDisabled If the collider is disabled no collision detection should be possible even if a collision checking method is called bool Both Method Implementations Method Description Return Type isColliding(out GameObject collide) Returns true if it is colliding and false if it isn't. It also sets the collide variable to the GameObject class of the collide bool isColliding Returns true if it is colliding and false if it isn't bool isCollidingWith(GameObject gameObject) Returns true if it is colliding with the specified GameObject bool","title":"Collider"},{"location":"Core/Components/Collider/#collider","text":"","title":"Collider"},{"location":"Core/Components/Collider/#description","text":"The collider is an interface used by Sprite2D and Shape2D , you will not need it to develop you game except if you want to create a custom GameObject class which supports collision.","title":"Description"},{"location":"Core/Components/Collider/#variable-implementations","text":"Variable Name Description Type Get/Set isColliderDisabled If the collider is disabled no collision detection should be possible even if a collision checking method is called bool Both","title":"Variable Implementations"},{"location":"Core/Components/Collider/#method-implementations","text":"Method Description Return Type isColliding(out GameObject collide) Returns true if it is colliding and false if it isn't. It also sets the collide variable to the GameObject class of the collide bool isColliding Returns true if it is colliding and false if it isn't bool isCollidingWith(GameObject gameObject) Returns true if it is colliding with the specified GameObject bool","title":"Method Implementations"},{"location":"Core/Components/GameObject/","text":"GameObject Description Think of the GameObject class as the root of all components. It defines a few necessary methods and variables that every component needs. Any component which can be rendered is a child of the GameObject class. Public Methods Method Description DestroySelf Removes the object from the game engine Disclaimer: If you are holding a reference of the GameObject then the GC (Garbage Collector) will not collect it unless you dispose it. Properties Name Description Type Position The position of the object Vector2 Scale The scale of the object Scale Tag A string identifier for the object string renderingPriority The highest number will be infont of a smaller one, check out the renderer section for more details on how the renderer works uint type Saves resources by specifing the type of the GameObject, find out more in the renderer section System.Type Useful links: Sprite2D MollyEngine Class Vector2","title":"GameObject"},{"location":"Core/Components/GameObject/#gameobject","text":"","title":"GameObject"},{"location":"Core/Components/GameObject/#description","text":"Think of the GameObject class as the root of all components. It defines a few necessary methods and variables that every component needs. Any component which can be rendered is a child of the GameObject class.","title":"Description"},{"location":"Core/Components/GameObject/#public-methods","text":"Method Description DestroySelf Removes the object from the game engine Disclaimer: If you are holding a reference of the GameObject then the GC (Garbage Collector) will not collect it unless you dispose it.","title":"Public Methods"},{"location":"Core/Components/GameObject/#properties","text":"Name Description Type Position The position of the object Vector2 Scale The scale of the object Scale Tag A string identifier for the object string renderingPriority The highest number will be infont of a smaller one, check out the renderer section for more details on how the renderer works uint type Saves resources by specifing the type of the GameObject, find out more in the renderer section System.Type Useful links: Sprite2D MollyEngine Class Vector2","title":"Properties"},{"location":"Core/Components/Shape2D/","text":"Shape2D Description The Shape2D is used to render squares with a single color. It is build on top of the GameObject class and the Collider interface, so it has access to variables and methods defined withing those classes, it is advised that you look into those classes in order to find out more. Properties Property Description Type Default Value Color The color of the shape System.Drawing.Color Red Constructors Signature Vector2 position, Scale scale, Color color, string tag, uint renderingPriority Vector2 position, Scale scale, string tag Vector2 position, Scale scale, Color color Vector2 position, Scale scale Useful links: GameObject Vector2 Scale","title":"Shape2D"},{"location":"Core/Components/Shape2D/#shape2d","text":"","title":"Shape2D"},{"location":"Core/Components/Shape2D/#description","text":"The Shape2D is used to render squares with a single color. It is build on top of the GameObject class and the Collider interface, so it has access to variables and methods defined withing those classes, it is advised that you look into those classes in order to find out more.","title":"Description"},{"location":"Core/Components/Shape2D/#properties","text":"Property Description Type Default Value Color The color of the shape System.Drawing.Color Red","title":"Properties"},{"location":"Core/Components/Shape2D/#constructors","text":"Signature Vector2 position, Scale scale, Color color, string tag, uint renderingPriority Vector2 position, Scale scale, string tag Vector2 position, Scale scale, Color color Vector2 position, Scale scale Useful links: GameObject Vector2 Scale","title":"Constructors"},{"location":"Core/Components/Sprite2D/","text":"Sprite2D Description Most if not all of your GameObjects will be of type Sprite2D. Sprite2D allows for the rendering/control of an image on the screen. It is a child of the GameObject class and it also implements the Collider interface. The implementations/methods/properties inherited by those classes will not be listed here and can be found at the appropriate docs. Public Methods Method & Signature Description Return Type setImage(string directory) Sets the sprites image to another image located in the giver directory void setImage(string directory, Scale scale) Sets the sprites image to another image located in the giver directory and resized it accordingly void getImage Returns the sprites image Bitmap Properties Property Description Type Directory The directory in which the sprites image is stored string Constructors Signature Description Vector2 position, Scale scale, string directory, string tag, uint renderingPriority - Vector2 position, Scale scale, string directory, string tag renderPriority has its default value 0 Vector2 position, Scale scale, string directory renderPriority has its default value 0 and tag is equal to an empty string Useful links: GameObject MollyEngine Class Camera","title":"Sprite2D"},{"location":"Core/Components/Sprite2D/#sprite2d","text":"","title":"Sprite2D"},{"location":"Core/Components/Sprite2D/#description","text":"Most if not all of your GameObjects will be of type Sprite2D. Sprite2D allows for the rendering/control of an image on the screen. It is a child of the GameObject class and it also implements the Collider interface. The implementations/methods/properties inherited by those classes will not be listed here and can be found at the appropriate docs.","title":"Description"},{"location":"Core/Components/Sprite2D/#public-methods","text":"Method & Signature Description Return Type setImage(string directory) Sets the sprites image to another image located in the giver directory void setImage(string directory, Scale scale) Sets the sprites image to another image located in the giver directory and resized it accordingly void getImage Returns the sprites image Bitmap","title":"Public Methods"},{"location":"Core/Components/Sprite2D/#properties","text":"Property Description Type Directory The directory in which the sprites image is stored string","title":"Properties"},{"location":"Core/Components/Sprite2D/#constructors","text":"Signature Description Vector2 position, Scale scale, string directory, string tag, uint renderingPriority - Vector2 position, Scale scale, string directory, string tag renderPriority has its default value 0 Vector2 position, Scale scale, string directory renderPriority has its default value 0 and tag is equal to an empty string Useful links: GameObject MollyEngine Class Camera","title":"Constructors"},{"location":"Extensions/Animator/","text":"","title":"Animator"},{"location":"Extensions/PlayerController/","text":"","title":"PlayerController"},{"location":"Misc/renderer/","text":"Renderer Description The Renderer is in the Misc section because it is not some sort of class or struct that the developer, it can only be called by the Engine itself. The renderer though is documented so that you can understand the rendering system of your game. How Does it Work When is it called The renderer method is being called every frame after the OnDraw event has been completed. Order of operation The rendering does the following, in the following order. Clears the screen and fills it with the background color. Updates the camera position. Creates a list of all the elements in the game it will need to render. Due to the fact that a Shape2D is rendered differently than a Sprite2D and that the rendering list is made out of GameObjects we need to identify every GameObject who's type is null/undefined. Loops through our list of GameObjects we need to render and checks whether or not the GameObjects priority is equal to the currentRenderingPriority . Every time the loop is completed the currentRenderingPriority is incremented and any items that have been rendered are removed from our list of GameObjects we need to render. Notes The rendering algorithm used by MollyEngine is far from perfect and some flaws do exist. For example if you have 2 objects(a and b) and objects a rendering priority is 0 while objects b rendering priority is 100 the loop will run 100 times untill the currentRenderingPriority reaches 100. Feature planning The rendering algorithm is on my TODO list of thing to fix/update since I have already come up with a few ways too make it more efficient.","title":"Renderer"},{"location":"Misc/renderer/#renderer","text":"","title":"Renderer"},{"location":"Misc/renderer/#description","text":"The Renderer is in the Misc section because it is not some sort of class or struct that the developer, it can only be called by the Engine itself. The renderer though is documented so that you can understand the rendering system of your game.","title":"Description"},{"location":"Misc/renderer/#how-does-it-work","text":"","title":"How Does it Work"},{"location":"Misc/renderer/#when-is-it-called","text":"The renderer method is being called every frame after the OnDraw event has been completed.","title":"When is it called"},{"location":"Misc/renderer/#order-of-operation","text":"The rendering does the following, in the following order. Clears the screen and fills it with the background color. Updates the camera position. Creates a list of all the elements in the game it will need to render. Due to the fact that a Shape2D is rendered differently than a Sprite2D and that the rendering list is made out of GameObjects we need to identify every GameObject who's type is null/undefined. Loops through our list of GameObjects we need to render and checks whether or not the GameObjects priority is equal to the currentRenderingPriority . Every time the loop is completed the currentRenderingPriority is incremented and any items that have been rendered are removed from our list of GameObjects we need to render.","title":"Order of operation"},{"location":"Misc/renderer/#notes","text":"The rendering algorithm used by MollyEngine is far from perfect and some flaws do exist. For example if you have 2 objects(a and b) and objects a rendering priority is 0 while objects b rendering priority is 100 the loop will run 100 times untill the currentRenderingPriority reaches 100.","title":"Notes"},{"location":"Misc/renderer/#feature-planning","text":"The rendering algorithm is on my TODO list of thing to fix/update since I have already come up with a few ways too make it more efficient.","title":"Feature planning"}]}